% A 13-layer Convolutional Neural Network of Alternating Convolution and
% Max-Pooling layers for Feature Learning as seen in 
% "Mitosis Detection in Breast Cancer Histology Images with Deep Neural
% Networks" by Dan C. Ciresan, Alessandro Giusti, Luca M. Gambardella, Jurgen Schmidhuber
%
% @Author: Christoph Baur

% Parameters
% d = 10px (All px within a 10px radius around a mitosis px are also
% considered mitosis pixels)
% patchsize = [101 101]

% Architecture of the network
% Layer 0: Input Layer, 3 channels @ 101x101px
% Layer 1: Convolution Layer, 16 channels @ 100x100px, 2x2 filters
% Layer 2: MaxPooling Layer, 16 channels @ 50x50px, 2x2 filters
% Layer 3: Convolution Layer, 16 channels @ 48x48px, 3x3 filters
% Layer 4: MaxPooling Layer, 16 channels @ 24x24px, 2x2 filters
% Layer 5: Convolution Layer, 16 channels @ 22x22px, 3x3 filters
% Layer 6: MaxPooling Layer, 16 channels @ 11x11px, 2x2 filters
% Layer 7: Convolution Layer, 16 channels @ 10x10px, 2x2 filters
% Layer 8: MaxPooling Layer, 16 channels @ 5x5px, 2x2 filters
% Layer 9: Convolution Layer, 16 channels @ 4x4px, 2x2 filters
% Layer 10: MaxPooling Layer, 16 channels @ 2x2px, 2x2 filters
% Layer 11 and 12: Fully Connected Network for Classification Using SoftMax
% activation

function net = network1()
f = 0.1;
% About filters: [height, width, channels, numFilters] - init with small random
% Single values
% About biases: vector with as much entries as numFilters
net = struct;
net.layers = {} ;
% Layer 1, results in 100x100px
net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(2,2,3,16, 'single'), ...
                           'biases', zeros(1, 16, 'single'), ...
                           'stride', 1, ...
                           'pad', 0);
% Layer 2, results in 50x50px                       
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [2 2], ...
                           'stride', 2, ...
                           'pad', 0) ;
% Layer 3, results in 48x48px
net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(3,3,16,16, 'single'), ...
                           'biases', zeros(1, 16, 'single'), ...
                           'stride', 1, ...
                           'pad', 0);
% Layer 4, results in 24x24px                       
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [2 2], ...
                           'stride', 2, ...
                           'pad', 0) ;
% Layer 5, results in 22x22px
net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(3,3,16,16, 'single'), ...
                           'biases', zeros(1, 16, 'single'), ...
                           'stride', 1, ...
                           'pad', 0);
% Layer 6, results in 11x11px                    
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [2 2], ...
                           'stride', 2, ...
                           'pad', 0) ;
% Layer 7, results in 10x10px
net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(2,2,16,16, 'single'), ...
                           'biases', zeros(1, 16, 'single'), ...
                           'stride', 1, ...
                           'pad', 0);
% Layer 8, results in 5x5px                       
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [2 2], ...
                           'stride', 2, ...
                           'pad', 0) ;
% Layer 9, results in 4x4px
net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(2,2,16,16, 'single'), ...
                           'biases', zeros(1, 16, 'single'), ...
                           'stride', 1, ...
                           'pad', 0);
% Layer 10, results in 2x2px                     
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [2 2], ...
                           'stride', 2, ...
                           'pad', 0) ;
                       
% Layer 11 and Layer 12: Fully Connected Network for classification
net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(2,2,16,100, 'single'), ...
                           'biases', zeros(1, 100, 'single'), ...
                           'stride', 1, ...
                           'pad', 0);
net.layers{end+1} = struct('type', 'conv', ...
                           'filters', f*randn(1,1,100,2, 'single'), ...
                           'biases', zeros(1, 2, 'single'), ...
                           'stride', 1, ...
                           'pad', 0);
net.layers{end+1} = struct('type', 'softmaxloss') ;

% Other details
net.normalization.imageSize = [101, 101, 3] ;

end